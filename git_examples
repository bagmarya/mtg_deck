Проверяем, что Git установился:

$ git --version

Первым делом, необходимо выполнить настройку Git. С помощью команд указанных ниже, установите имя и почту.

$ git config --global user.name "Mona Lisa"
$ git config --global user.email "mona@lisa.io"

Эти данные используются в коммитах для понимания того, кто был автором коммита.

Для инициализации нужно выполнить команду git init внутри той директории, которая станет репозиторием.

~$ cd example/
# Команда инициализации
example$ git init

Инициализация создаёт директорию .git.


Убедиться в том, что репозиторий инициализирован и находится в работоспособном состоянии можно командой git status:



КОММИТ:

# Создаём файл
example$ touch README.md
# Меняем содержимое
example$ echo '# Hi' > README.md
# Так Git увидит новый файл
example$ git add README.md
 # Коммит с сообщением 'init project'
example$ git commit -m 'init project'
[master (root-commit) 679e31d] init project
 1 file changed, 1 insertion(+)
 create mode 100644 README.md

 
 можно посмотреть историю коммитов:
example$ git log


git log -p  выводит непрерывную разницу (diff) всех изменений по коммитам. Строчки, в которых слева находится знак +, добавлены в этом коммите, а строчки, в которых есть - — удалены. Нажимая f и b в этом выводе, можно перемещаться по истории изменений если она не помещается на экран.

Зная идентификатор коммита можно посмотреть изменения в коде.
$ git show 3a64fccf14725593b7486ff09d6a6c325a5f8fcc
можно идентификатор писать не полностью, достаточно указать только первые 7 символов идентификатора коммита
$ git show 3a64fcc

команда git diff, запущенная без аргументов, показывает различия между репозиторием и вашей рабочей копией. Её полезно запускать тогда, когда вы хотите посмотреть изменения сделанные в рабочей копии, но не добавленные для коммита командой git add.


специальный файл .gitignore, который поможет Git определить то, что точно не придётся коммитить. 


    git reset path/to/file переводит файл из состояния staged в modified
    git checkout -- path/to/file переводит файл из состояния modified в unmodified, то есть по сути эта команда сбрасывает изменения.

    
    
    git checkout идентификатор. После этой команды, в рабочей копии окажется то состояние репозитория, которое было на момент коммита идентификатор.
    
 ВЕТВЛЕНИЕ, СЛИЯНИЕ И ПЕРЕБАЗИРОВАНИЕ: 
 
 Чтобы создать ветку и сразу переключиться на нее, можно выполнить команду git checkout с параметром -b:

$ git checkout -b iss53
Switched to a new branch "iss53"

Это тоже самое что и:

$ git branch iss53
$ git checkout iss53


    
    git branch. - покажет в какой мы ветке
    
    git branch new-feature # создание новой ветки
    
    git branch -d client  # удаление ветки client

    git checkout new-feature # переключение на новую ветку
    
    git checkout ed8145e # переключение на другой комит
    
    git checkout master   #слияние ветки new-feature
    git merge new-feature # с веткой master
    
    Команда git merge выполняется из той ветки, в которую мы сливаем изменения, а аргументом передаётся имя той ветки, которую мы сливаем.
    
    
    есть и другой способ: вы можете взять те изменения, что были представлены в сливаемой ветке new-feature и применить их поверх master. В Git это называется перебазированием. С помощью команды rebase вы можете взять все коммиты из одной ветки и в том же порядке применить их к другой ветке.
    В данном примере переключимся на ветку experiment и перебазируем её относительно ветки master следующим образом:

$ git checkout experiment
$ git rebase master
First, rewinding head to replay your work on top of it...
Applying: added staged command


    После этого, вы должны переключиться обратно на ветку master и выполнить слияние перемоткой (fast-forward):

$ git checkout master
$ git merge experiment


РЕПОЗИТОРИИ И КЛОНИРОВАНИЕ:
    
    Центральный репозиторий не имеет рабочей копии и создается так:
    
    $ mkdir example_bare
    $ cd example_bare
    example_bare$ git init --bare
    
    
    Теперь можно перейти в другую директорию и попробовать клонировать только что созданный репозиторий. Для простоты используем директорию /tmp.

    $ cd /tmp
    # Переименуем папку клонированного репозитория для того чтобы не путаться
    tmp$ git clone ~/example_bare clone_of_example
    
    clone_of_example$ git remote -v
    #сообщит нам где центральный репозиторий

    
    
    пример отправки изменений:
clone_of_example$ echo '# Hello' > README.md
clone_of_example$ git add README.md
clone_of_example$ git commit -am 'add readme'
[master 144d274] replace readme
 1 file changed, 1 insertion(+), 0 deletions(-)

# Отправка
clone_of_example$ git push origin master  # 'origin' - это имя центрального 
                                            # репозитория
Counting objects: 3, done.
Writing objects: 100% (3/3), 253 bytes | 0 bytes/s, done.
Total 3 (delta 0), reused 0 (delta 0)
To /home/user/example_bare
   3a64fcc..144d274  master -> master

Здесь origin — имя удалённого репозитория, master — конкретная ветка, в которую отправляются (разг. пушатся) изменения. Каждый раз набирать эту команду полностью довольно утомительно. Поэтому Git позволяет не указывать удалённую ветку, если сделать её «отслеживаемой веткой» (upstream branch).

Отслеживаемая ветка устанавливается командой git push --set-upstream origin master. Эта команда выполняет два действия: устанавливает отслеживание и отправляет изменения. Она выполняется ровно один раз, далее можно отправлять изменения набирая просто git push. Информация об отслеживаемой ветке описывается в файле .git/config в виде секций [branch "имя ветки"]:

git pull - получить изменения, сделанные в удалённом репозитории, а затем слить их со своими.


если в нашей локальной ветке не было изменений и произойдёт так называемое слияние в режиме fast forward

в ситуации, когда мы делаем git pull, а в локальной ветке есть зафиксированные изменения, произойдёт  git merge. Под капотом git pull делаются две операции — одна git fetch, которая просто получает изменения и складывает их к себе во внутренности директории .git, а вторая — git merge.

git pull --rebase - Если в процессе возникнут конфликты, то вас попросят их решить. 
(Если вы используете git pull и хотите использовать --rebase по умолчанию, вы можете установить соответствующее значение конфигурации pull.rebase с помощью команды git config --global pull.rebase true.)


Если вы хотите посмотреть на то, как выглядит история коммитов с учётом ветвления, вам поможет команда, показанная ниже.

racket$ git log --oneline --decorate --graph


# Пример клонирования репозитория https://github.com/Hexlet/ru-test-assignments в директорию /tmp

# Клонирование
tmp$ git clone https://github.com/Hexlet/ru-test-assignments.git
























Команда git rebase относится к продвинутым техникам Git, но именно она делает вас настоящим властелином репозиториев. Как только основы будут освоены, окунитесь в её изучение.









!!!!!!!!!!!!!!!!!!GEEKBRAINS!!!!!!!!!!!!!!!
.gitkeep - созданный в пустой дирректории позволяет включить в индекс пустые директории
.gitignore - позволяет задать файлы и директории игнорируемые гитом для индекса и коммитов

git config --global  color.ui auto - включить автоподсветку в консоли
git config --list -посмотреть конфиг


git clone _ссылка_ - клонировать репозиторий
git remote add origin https://github.com/bagmarya/stepik_exercises.git - добавить удаленный репозиторий
git remote -v

git log - просмотр истории коммитов
git reflog - просмотр истории действий
git reset - сброс текущего состояния истории
git revert - отмена последствий коммита
git restore - сброс состояния файла на указанное



git branch - смотрим ветки
git branch dev - создаем новую ветку DEV
(можно опционально задать корень новой ветки, если находишься не на той откуда растет новая git branch dev master - создаст новую ветку на ветке master)

git checkout dev - переключиться на ветку dev
(можно операции создания и переключения объединить git checkout -b dev )

